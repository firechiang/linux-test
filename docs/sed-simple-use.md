#### sed 文件流编辑器简单使用（修改删除文件里面的数据）（注意：sed命令处理是以文件里面的行为单位的，它是一行一行匹配处理的）
 - [sed 文件流编辑器的测试脚本，统计和过滤文件里面的段落（里面有删除注释行和空行）](https://github.com/firechiang/linux-test/tree/master/sh/sed-test.sh)
```bash
# 使用方法一：sed [option] "pattern command" file
# 使用方法二：命令 | sed [option] "pattern command"
# option 包含以下值（注意：option 为可选参数）
# -n 只打印模式匹配行（就是只打印，已有的数据，不会重复打印（默认是打印已有数据和匹配的数据，这样一行数据就会打印两次））
# -e 直接在命令行进行sed编辑（其实就是可以跟多个匹配）（这个也是默认选项）
# -f 编辑动作保存在文件中，指定文件执行（就是操作命令写在文件里面，指定一个文件里面有操作命令）
# -r 支持扩展正则表达式
# -i 直接修改文件内容

# pattern 用法（注意：command 表示命令，比如 p等；pattern 表示正则表达式）
# 10command                              # 匹配到第10行
# 10,20command                           # 匹配从第10行开始，到20行结束
# 10,+5command                           # 匹配从第10行开始，到16行结束
# /pattern1/command                      # 匹配到pattern1的行
# /pattern1/,/pattern2/command           # 匹配到pattern1开始，pattern2结束
# /pattern1/,$command                    # 匹配到pattern1开始，最后一行结束（注意：$ 表示最后一行）
# 10/pattern1/command                    # 匹配从第10行开始，到pattern1结束       
# /pattern1/10command                    # 匹配从pattern1开始，到第10行结束      

# command（命令） 包含以下值
# p 打印
# a 行后追加
# i 行前追加
# r 外部文件读入，行后追加
# w 匹配行写到外部文件
# d 删除
# = 打印行号
# s/pattern/string/                      # 将匹配到的pattern字符串修改成string（注意：这个只修改第一个）
# s/pattern/string/g                     # 将匹配到的pattern字符串修改成string（注意：这个是修改所有的）
# s/pattern/string/ig                    # 将匹配到的pattern字符串修改成string（注意：i 表示匹配时忽略大小写，这个是修改所有的）
# s/pattern/string/2g                    # 将匹配到的pattern字符串修改成string（注意：每一行，修改前两个）
# s/pattern/string/3g                    # 将匹配到的pattern字符串修改成string（注意：每一行，修改前三个）

$ sed -n 'p' aaa                         # 打印输出aaa文件里面的每一行（注意：'p' 就是打印输出的意思，-n 是只打印已有数据，不会重复打印）
$ sed -n '=;p' aaa                       # 打印输出aaa文件里面的每一行（注意：多个命令用分号隔开，'=' 表示显示行号的意思 ，p 表示打印输出，-n 是只打印已有数据，不会重复打印）
$ sed -n '2,5p' aaa                      # 打印输出aaa文件第2行到第5行的数据（注意：'p' 就是打印输出的意思，-n 是只打印已有数据，不会重复打印）
$ sed -n '/00000/ p' aaa                 # 打印输出aaa文件里面能匹配到00000的每一行数据（注意：/00000/ 表示正则表达式，'p' 就是打印输出的意思，-n 是只打印已有数据，不会重复打印）
$ sed -n -r '/aa|AA/ p' aaa              # 打印输出aaa文件里面能匹配到aa或AA的每一行数据（注意：'p' 就是打印输出的意思，-r 支持扩展正则表达式（aa|AA就是扩展的正则表达式），-n 是只打印已有数据，不会重复打印）
$ sed -n '/\[.*\]/p' aaa                 # 打印输出aaa文件里面以[开头，后面跟0个或多个任意任意字符，最后以]结尾的数据（注意：\ 表示转义）
$ sed -n -e '/00/ p' aaa -e '/30/ p' aaa # 对多个文件进行匹配搜索打印（-e 就是指定多个匹配项和文件（注意：每个匹配项都要加上-e））

# 打印输出aaa文件里面以[开头，后面跟0个或多个任意任意字符，最后以]结尾的数据（注意：\ 表示转义）
# 再将 [] 替换掉，再输出
$ sed -n '/\[.*\]/p' aaa | sed -n -e 's/\[//g' -e 's/\]//g;p'

$ sed -n 's/kommo/qqq/g' aaa             # 将文件aaa里面的kommo修改为qqq，不会修改原文件（注意：s 表示修改，g 表示修改所有；这样不会修改源文件，也不会有输出）
$ sed -n 's/kommo/qqq/g;p' aaa           # 将文件aaa里面的kommo修改为qqq，不会修改原文件（注意：s 表示修改，g 表示修改所有，p表示打印修改后的结果；这样不会修改源文件，但是会将修改后的信息输出出来）
$ sed -i 's/kommo/qqq/' aaa              # 修改文件aaa里面的kommo修改为qqq，直接修改原文件（注意：只会修改每一行的第一个，s 表示修改；这个是直接将文件里面的内容改了）
$ sed -i 's/kommo/qqq/g' aaa             # 修改文件aaa里面的kommo修改为qqq，直接修改原文件（注意：s 表示修改，g 表示修改所有；这个是直接将文件里面的内容改了）

$ sed -i '5,10s/kommo/qqq/g' aaa         # 修改aaa文件里面的5-10行，将kommo修改为qqq，直接修改原文件（注意：s 表示修改，g 表示修改所有；这个是直接将文件里面的内容改了）
$ sed -i '/^root/,10s/kommo/qqq/g' aaa   # 修改aaa文件里面从root开头的行到第10行，将kommo修改为qqq，直接修改原文件（注意：s 表示修改，g 表示修改所有；这个是直接将文件里面的内容改了）
$ sed -i '/dsfsdfds/s/fds/qqq/g' aaa     # 修改aaa文件里面匹配到dsfsdfds的所有行，将fds修改为qqq，直接修改原文件（注意：s 表示修改，g 表示修改所有；这个是直接将文件里面的内容改了）
$ sed -i '/sdfs/,/qqqssd/s/ssd/AAA/g' aaa# 修改aaa文件里面匹配sdfs到qqqssd的所有行，将ssd修改为AAA，直接修改原文件（注意：s 表示修改，g 表示修改所有；这个是直接将文件里面的内容改了）

$ sed -i "s/${AAA}/S/g" aaa              # 修改aaa文件，将AAA变量的值修改为S（注意：使用变量建议将整个表达式使用双引号包起来）
$ sed -i 's/${AAA}/'$AAA'/g' aaa         # 修改aaa文件，将${AAA}修改为AAA变量的值（注意：使用变量可以将获取变量的部分用单引号包起来）

$ sed -i '/444\/444\/44/a DD' aa         # 修改文件aa，在文件里面找到444/444/44所在行（\ 表示转义），在它下面新建一行，数据为DD（注意：是所有匹配行都会加）
$ sed -i '/444444444444/a DD' aa         # 修改文件aa，在文件里面找到444444444444所在行，在它下面新建一行，数据为DD（注意：是所有匹配行都会加）
$ sed -i '/444444444444/i DD' aa         # 修改文件aa，在文件里面找到444444444444所在行，在它上面新建一行，数据为DD（注意：是所有匹配行都会加）

$ sed -i '/DD/r add.txt' aa              # 修改文件aa，在文件里面找到DD所在行，在它下面新建一行，将add.txt文件里面的数据加进去（注意：是所有匹配行都会加）
$ sed -i '20r add.txt' aa                # 修改文件aa，在文件的第20行下面新建一行，将add.txt文件里面的数据加进去
$ sed -i '/^root/,20r add.txt' aa        # 修改文件aa，从root开头的行开始到第20行，每一行下面新建一行，将add.txt文件里面的数据加进去
$ sed -i '/^root/,/jiang$/r add.txt' aa  # 修改文件aa，从root开头的行开始到以jiang的行结束，每一行下面新建一行，将add.txt文件里面的数据加进去

$ sed -i '/DD/w /home/grep/add1.txt' aa  # 将aa文件里面包含DD的行数据，保存到/home/grep/add1.txt文件中
$ sed -i '/^root/,/ji$/w /h/g/a1.txt' aa # 将aa文件从root开始的行到ji结尾的行行数据，保存到/h/g/a1.txt文件中

$ sed -n '1d' aa                         # 删除aa文件里面的第1行数据（注意：这个不会修改文件）
$ sed -n '1d;p' aa                       # 删除aa文件里面的第1行数据，并打印修改后的数据（注意：这个不会修改文件）
$ sed -i '1d' aa                         # 删除aa文件里面的第1行数据（注意：这个会修改文件）
$ sed -i '1,10d' aa                      # 删除aa文件里面的第1行到第10行的数据（注意：这个会修改文件）
$ sed -i '1,+5d' aa                      # 删除aa文件里面的第1行到第（1+5=6）行的数据（注意：这个会修改文件）
$ sed -i '/43/d' aa                      # 删除aa文件里面包含43的行数据（注意：这个会修改文件）
$ sed -i '/ff/,/67/d' aa                 # 删除aa文件里面的数据，从包含ff的行数据开始到包含67行数据结束（注意：这个会修改文件）
$ sed -i '/[:blank:]*#/d;/^$/d' aa       # 删除aa文件里面，以空格开头后面跟着0个或多个空格再跟着一个#号的行数据（注意：多个命令可以;号隔开，:blank:就是匹配空格，这个可以看作是注释行的匹配）

# 高级用法，反向引用简单使用（将正则表达式匹配到的字符串作为变量使用，使用 &或\1 获取该值）
# 修改文件aa里面的内容（匹配到以ma开头，后面跟2个任意字符（.表示匹配任意字符），以n结尾的字符串。在这些字符串后面加上QQ字符）
# 注意：& 表示正则表达式匹配到的字符串
$ sed -i 's/ma..n/&QQ/g' aa 
# 修改aa文件将里面非#号开头的行，前面加入*号（[^#] 表示非#号，& 表示正则表达式匹配到的字符串）   
$ sed -i 's/^[^#]/\*&/g' aa
# 注意：\1 表示正则表达式匹配到的字符串，使用\1的时候必须把正则表达式用括号括起来，而且括号也需要用\转义
$ sed -i 's/\(ma..n\)/\1QQ/g' aa
# 注意：使用 \1 更加灵活，\1只获取括号里面匹配到的值，就是整个正则表达式，我们可以用括号括起其中一段，用\1获取该段所匹配到的值（如下列子\1获取到的就是QQ两个字符） 
$ sed -i 's/ma...\(QQ\)/\1AA/g' aa
```